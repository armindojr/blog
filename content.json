{"pages":[{"title":"","text":"Teste","link":"/about/"}],"posts":[{"title":"Como aprendi novas skills modificando o FakerJS","text":"O que é o pure-genO pure-gen é basicamente um gerador de dados falsos para preenchimento de formulários de teste baseados em uma localidade do mundo. Assim podendo gerar nomes, e-mails, documentos e outras funcionalidades que são únicas de cada país. A base do projetoPara criar o pure eu usei como base um projeto muito conhecido pelo pessoal de QA, o Faker.js. O projeto já está bem consolidado como um dos mais famosos gerador de dados de JS. Porém no cenário que vi dentro da equipe que trabalhei, algumas coisas no projeto estavam há muito tempo sem serem atualizadas ou melhoradas, principalmente a parte de localização em PT_BR que possuía algumas falhas. Levando isso em consideração eu pensei em apenas atualizar a localização e criar uma PR para o projeto original. Porém quando fui visitar a pagina de PR’s pendentes no Faker.js percebi que tinham muitas alterações pendentes importantes e que o dono original não implementava. O criador original tem seus motivos para manter o projeto no estado atual, entretanto eu decidi criar o meu próprio baseado neste e implementar as alterações que minha equipe precisava sem depender da boa vontade de outras pessoas e ainda de quebra adquirir um conhecimento diferenciado sobre diversas coisas, nada melhor que um DIY. Mudanças que fiz no projetoDentre as mudanças que considero importantes feitas no projeto são: Implementei manualmente no meu código muitos PR’s que estavam pendentes do projeto original Adicionei alguns métodos novos para geração de dados Arrumei bugs diversos como : memory leak, criação de ambiente baseado em uma SEED por array, métodos que retornavam undefined e diversas outras coisas Modifiquei o back-end de geração de RNG, que antes usava um PRNG do tipo mersenne-twister e agora usa um PRNG baseado em lfib que demonstrou ter um desempenho incrivelmente melhor quando usado em larga escala Implementei a utilização do husky e do eslint para garantir a qualidade do código entregue Melhorei a cobertura de código nos testes unitários e refatorei todos os testes para executarem mais rapidamente no CI tendo a mesma cobertura. Implementei uma compressão de dados estáticos em GZIP para diminuir o tempo de instalação e o volume de dados do projeto, tendo impacto 0 na funcionalidade Melhorias gerais no código, removendo blocos comentados e arrumando alguns TODO. Essas são algumas das principais mudanças que fiz, caso queira entender melhor o que foi alterado, como foi feito e ver todas as mudanças realizadas é só acessar o changelog. O que aprendi modificando esse projetoParece meio ambicioso modificar um projeto desse nível e achar que tem algo a incrementar … mas pude tirar proveito para aprender os seguintes itens criando meu próprio gerador de dados: Como funcionam testes unitários e para que servemExecução de testes em um ambiente CI para demonstrar falhas Como funcionam os relatórios de cobertura de códigoRefatoração e melhoria de um código já existente Como funcionam os geradores de números aleatórios Compressão de dados estáticos Como criar meu próprio projeto no NPM Como criar uma documentação que possa demonstrar o funcionamento do seu projeto Se posso tirar uma lição disso é que se tem algo que você vê na comunidade que pode melhorar, abrace o projeto, se possível chame alguns amigos e se desafiem a melhorar, tive uma experiência muito boa e um dos melhores aprendizados, inclusive, para quem quiser conferir tudo que escrevi na prática ou ainda contribuir para o projeto, seguem os links: GithubNPM Valeu pessoal, até a próxima!","link":"/2020/05/como-aprendi-novas-skills-modificando-o-FakerJS/"},{"title":"Automação de testes E2E com Webdriver.IO","text":"Objetivos deste guiaEste guia não abordará métodos de como deixar o código limpo, organização da suíte de testes e utilização de serviços externos ao core que ajudam nos testes. O principal objetivo é mostrar os primeiros passos com a automação de testes E2E com o webdriver.io. Por trás da frameworkO webdriver.io hoje em dia possui como mantenedor principal o Christian Bromann, Desenvolvedor/QA que participa do time do Saucelabs. O projeto do Webdriverio está também inserido no ecossistema projetos da JS Foundation, nos quais também estão inseridos projetos de peso do Javascript tais como : Appium, ESlint, Grunt, jQuery, Mocha e outros. Por quê utilizar o webdriver.io ?Esse é sempre um questionamento que é feito ao aprender algo novo. Cada framework de automação de testes E2E tem seus prós e contras. Não será realizada a comparação entre as frameworks, nessa guia serão apontados alguns pontos positivos na utilização. Estes são : Comunidade ativa :A comunidade em volta do webdriver.io sempre está ativa, implementando e desenvolvendo funcionalidades novas para serem inseridas na framework. Facilidade na configuração inicial :O webdriver.io dispõe de uma interface de configuração por terminal (CLI) que ajuda a realizar a configuração inicial do projeto. Criando assim um arquivo base que possui itens configuráveis, este arquivo que será executado para a inicialização dos testes. Debug em realtime e REPL :Um ponto considerado positivo desta framework em relação às outras, é o debug intuitivo que pode utilizar somente um breakpoint no próprio código. Além disso é possível contar com o REPL integrado ao pacote que realiza a mesma função do debug, mas sem precisar utilizar breakpoint. Desta forma, é possível executar sem a necessidade de escrever um arquivo inteiro para o teste. Compatibilidade :O webdriver.io é extremamente compatível com diversas funcionalidades úteis na execução e criação de testes E2E, principalmente se o teste for realizado em um ambiente na nuvem (browserstack / saucelabs) Documentação de fácil legibilidade :A documentação do webdriver.io é de fácil entendimento e legibilidade pois possui exemplos e descrição de forma sucinta. Seletores específicos para testes de apps em react :Recentemente foi implementado uma funcionalidade onde é possível utilizar alguns seletores específicos de elementos que não são comuns em html básico e que estão presentes em projetos com react. Enfim, mãos na massa. Será utilizado como base o teste da funcionalidade em um site de busca, onde esse site possui algumas peculiaridades. Deverão ser feitas validações para confirmar determinadas ações e utilizar funções de espera para que algo aconteça na página. Links úteisAprenda por definitivo a usar CSS SelectorWebdriverIO Website Configuração inicialO que é necessário ter instalado : Ter a versão mais recente do Node.JS, no guia foi utilizada a versão 10.15.3 Ter o JAVA instalado e configurado, no guia foi utilizado o openJDK 11.0.2 O primeiro passo é criar uma pasta para colocar seu projeto e a abrir no seu editor de código de sua preferência. Durante esse guia será utilizado o Visual Studio Code //imagem 1 Será utilizado o terminal que é possível abrir no próprio VSCode. //imagem 2 Em seguida, será criado o package.json onde vai ficar armazenado todos os pacotes deste projeto. Use o comando no terminal : 1npm init -y //imagem 3 Agora, serão instalados os pacotes e armazenados dentro do package.json para a utilização posterior em outras máquinas. Instale o Webdriver.IO e o CLI dele com o comando no terminal : 1npm i —-save-dev webdriverio @wdio/cli //imagem 4 Inicialize o projeto na pasta raiz que foi aberta no editor de texto com o comando no terminal : 1.\\node_modules\\.bin\\wdio config //imagem 5 As seguintes perguntas vão aparecer no terminal : P: Where should your tests be launched? (Onde os testes vão ser executados ?)R: localP: Shall I install the runner plugin for you? (Gostaria de instalar o plugin que executa os testes ?)R: Yes (Deixe a resposta como Sim)P: Where is your automation backend located? (Onde seu backend de automação vai estar ?)R: On my local machineP: Which framework do you want to use? (Qual a framework semântica à ser utilizada ?)R: jasmineP: Shall I install the framework adapter for you? (Gostaria de instalar o adaptador da framework ?)R: Yes (Deixe a resposta como Sim)P: Do you want to run WebdriverIO commands synchronous or asynchronous? (Você gostaria de executar os comandos de forma síncrona ou assíncrona ?)R: sync (Deixe a resposta como síncrona)P: Where are your test specs located? (Onde está localizada sua pasta de cenários ?)R: ./spec/*.jsP: Which reporter do you want to use?** (Qual o método de exibição da execução você quer usar ?)R: specP: Shall I install the reporter library for you? (Gostaria de instalar a biblioteca da exibição escolhida ?)R: Yes (Deixe a resposta como Sim)P: Do you want to add a service to your test setup?** (Gostaria de adicionar um serviço à sua configuração ?)R: selenium-standaloneP: Level of logging verbosity (Nível de log no modo verboso)R: silent (Nenhum warning será apresentado no console durante a execução)P: What is the base url? (Qual a url base da aplicação a ser testada ?)R: http://localhost As perguntas podem ser respondidas navegando com as setas e confirmar com o enter do teclado ** A pergunta que possui múltiplas escolhas a opção deve ser primeiro marcada com o espaço do teclado para só depois apertarmos enter. Após essa série de questionamentos sobre a configuração é criado o seguinte arquivo : //imagem 6 Agora crie a pasta spec/ //imagem 7 Dentro dessa pasta irão ficar todas as suítes de testes. Crie e abra um arquivo com o nome home.js dentro da pasta spec/. //imagem 8 Agora descreva os testes usando a sintaxe do Jasmine (Para saber mais basta entrar na documentação oficial) conforme mostra o guia abaixo. Resumidamente : O describe serve como separação de cada cenário do teste e o it é uma ação específica Descreva primeiro o cenário onde irá acessar a página inicial. //imagem 9 Depois de escrito, execute o teste no terminal, utilize o comando abaixo : 1.\\node_modules\\.bin\\wdio .\\wdio.conf.js Assim o browser será aberto (no caso o firefox pois ainda não foi configurado nenhum outro). //imagem 10 “Poxa, mas eu queria rodar meus testes no chrome, como faço ?” Simples, é só alterar o wdio.conf.js com as seguintes opções : //imagem 11 “Mas agora o chrome abre, porém não é em tela cheia …” Para isso, é necessário passar os seguintes argumentos para o webdriver : //imagem 12 Para incrementar um pouco o teste … Crie um cenário onde é realizada uma busca, clique em um resultado e verifique o carregamento. Antes de dar forma ao teste, é recomendado a leitura de como criar seletores em css para facilitar a escolha do elemento para o programa realizar alguma ação. No início do guia existem links úteis que irão auxiliar no entendimento do assunto. Assim, incremente os passos do cenário : //imagem 13 Os lugares onde ficaram espaços entre as funções, coloque as ações em si. Elas são compostas da seguinte forma : //imagem 14 //imagem 15 Perceba que no teste implementado existem funções além das que foram explicadas anteriormente : //imagem 16 Esse parece o seletor já utilizado, porém está retornando um Array com os itens da página, o índice mostra qual item desse Array será feita a interação e as ações são as mesmas de um seletor comum. //imagem 17 O browser é um objeto que possui ações específicas baseadas no próprio navegador, na imagem acima é retornado a title da página acessada. //imagem 18 Funcionalidade do framework semântico (jasmine), o expect serve para realizar uma verificação que um determinado item possui algo ou contém algo. Executando o script novamente, todos os resultados são exibidos no terminal indicando o que foi executado e o tempo de execução. //imagem 19 Considerações finaisO guia aborda apenas tópicos básicos para a primeira implementação de uma automação em JS com o Webdriver.io, é recomendado que todos os leitores se aprofundem nas funcionalidades extras que a ferramenta possui, tais como : execução de tasks com o grunt, relatórios de execução com melhor apresentação do allure, utilização das ultimas implementações do ECMAscript com o babel, testes de regressão visual e outras funcionalidades. Para quem conhece sobre o protractor e chegou até o final sem conseguir diferenciar os dois, lembre-se : o protractor foi criado pensando em testes de sites em angular, os desenvolvedores criaram uma flag pra utilizar sites que não foram desenvolvidos em angular, caso a aplicação em teste redirecionar para outra pagina. Assim a intenção da flag era apenas ser utilizada nesse caso, porém muitos tutoriais indicam que o QA habilite isso de forma permanente. Não é considerado um erro, porém a ferramenta não foi criada pra esse propósito, já que até a descrição no site do protractor é : “Protractor is an end-to-end test framework for Angular and AngularJS applications”. Existe uma grande diversidade de frameworks para testes E2E, porém o ideal é sempre avaliar e escolher a que melhor atende seu time e sua organização. O exercício vai ficar no bitbucket Valeu pessoal, até a próxima!","link":"/2019/05/automacao-de-testes-E2E-com-Webdriver-IO/"},{"title":"O paradoxo do pesticida em automação de testes","text":"De acordo com o syllabus do CTFL, certificação que garante conhecimentos básicos da área de qualidade, um dos sete princípios do teste é o Paradoxo do pesticida. Mas afinal, o que é este paradoxo e para que serve ? Primeiro vamos começar com a explicação do por quê esse nome e da história por trás.De acordo com a teoria da evolução, as espécies atuais descendem de outras espécies que sofreram modificações ao longo do tempo e passaram essas características para seus descendentes e essas características são relacionadas ao processo de seleção natural, na qual apenas os que possuem “as melhores características” deixam mais descendentes.Certo, mas qual a relação disso com o paradoxo do pesticida ? De forma resumida, foi realizado um estudo com um grupo de baratas do tipo Blattella germanica que mostrou que ao longo do tempo um determinado grupo de baratas apresentou um nível de resistência maior aos inseticidas. Assim, esse grupo com genética superior deixariam seus descendentes cada vez mais resistentes aos inseticidas comuns do mercado.A ligação dessa história por trás do estudo com baratas e com nossa área de qualidade é que quanto mais aplicamos os mesmos casos de teste no mesmo sistema a ser testado, menos os bugs vão aparecer naquela determinada área testada. Porém outros bugs podem ser criados em outras áreas do sistema que não são abordadas pelos casos de teste comuns criado pela equipe de qualidade. De acordo com o engenheiro de software Boris Beizer, que foi o primeiro a nomear e apresentar a definição do paradoxo do pesticida, todo método de prevenir ou encontrar bugs deixam um resíduo de problemas mais sutis nos quais os métodos em questão são ineficazes. Ele complementa também que, a complexidade do software (e os bugs desse) cresce até o limite da nossa habilidade de gerenciar essa complexidade. As suítes de testes se desgastam Pode ocorrer de uma suíte de teste que por um momento se mostrou bastante eficaz, se desgastar pois os programadores e os designers modificam seus hábitos na tentativa de reduzir a incidência de erros. Se você não organizar suas estatísticas de bugs em uma classificação racional, você pode não saber o quão efetivo seu teste foi e nem saber o quão desgastada sua suíte de teste está. Para efeitos de visualização do tema em questão, digamos que estamos testando um sistema onde nosso plano de teste aborda que a principal funcionalidade a ser testada seria a busca de um produto em um e-commerce e um dos casos de teste espera que o resultado de buscar o produto deveria ser a página de busca contendo o produto que foi buscado. Realizamos o nosso caso de teste e abrimos um bug indicando que a busca não mostrava o produto esperado. Quando os desenvolvedores finalizarem a correção do bug e constatarmos que a tarefa foi realmente finalizada corretamente, nossa suíte de testes que antes tinha um caso de teste que cobria um resultado específico se torna obsoleta por sempre verificar algo que já está correto. Assim, devemos incrementar nossos casos de teste para que atenda outros cenários que antes não eram esperados. Como evitar então que o paradoxo aconteça ? Podemos seguir a padronização internacional de criação de casos de teste (IEEE 829) durante o ciclo de desenvolvimento e no final da execução dos testes, reavaliar os casos e o desgaste da suíte criada mantendo assim um padrão onde sempre verificamos e atualizamos os testes a serem realizados mesmo que a suíte de teste antiga passe sem problemas. Referências CTFL, Syllabus 2018Cola da web, Adaptação dos seres vivosFapesp pesquisas, Baratas resistentes aos inseticidas 2002Boris Beizer, Software testing techniques 2d. Ed. — Infinite undo! blog 2002University of Otago, IEEE 829–1998 SummarySergio Barriviera, Padrão para documentação de teste de software 2012Devmedia, processo de teste de software 2012","link":"/2019/02/paradoxo-do-pesticida/"},{"title":"Paralelização de testes com Cypress","text":"Qual o motivo de paralelizar testes ?Recentemente fiz parte de um projeto onde tínhamos diversas pessoas que criavam e automatizavam cenários de testes no mesmo repositório para testes do tipo regressivo, aos poucos percebemos que nosso repositório de testes aumentou exponencialmente seu tempo de execução dentro do CI, e com isso estudamos diversas formas de melhorar esse tempo. Com todo esse background, decidimos optar por incluir a execução de testes de forma paralela. Como o Cypress funciona com a paralelizaçãoPor padrão, o Cypress possui uma integração com seu próprio dashboard para a realização desses tipos de testes, o chamado Cypress dashboard. Esse dashboard possui diversos benefícios tais como: Veja quantos testes falharam ou passaram Obtenha o rastreamento completo dos testes que possuem falha. Veja as capturas de tela tiradas com falha no teste. Assista a um vídeo de toda a sua execução de teste ou no ponto de falha. Gerencie quem tem acesso aos seus reports. Porém esse método traria os seguintes pontos negativos: Extremamente caro para grandes projetos Pouco controle sobre como a execução será feita, já que a dashboard tem um loadbalancer próprio Também chegamos em um pacote chamado sorry-cypress que serve pra substituir a dashboard do próprio Cypress, porém com essa implementação perderíamos o report unificado do mochawesome e teríamos uma dificuldade muito grande de implementar dentro do nosso CI. Por fim, decidimos em conjunto que iriamos tentar achar uma solução onde executaríamos o Cypress paralelamente dentro do próprio Jenkins utilizando apenas a sintaxe dentro do próprio jenkinsfile em conjunto com a visualização do plugin BlueOcean. Mas porque usar o Blue Ocean ?Este é um plugin criado para o Jenkins com o intuito de melhorar e facilitar as visualizações de toda interface dos Jobs, usamos ele pela forma como ele simplifica a execução do Job e por sua interface deixar o Jenkins mais clean, mostrando exatamente como a execução paralela está sendo feita e o console exato de cada POD. Diferente do console padrão do Jenkins que somente mostra os logs sequencialmente, o Blue Ocean quebra exatamente como os PODs estão configurados. Implementando a paralelização diretamente no CIComo já foi comentado, a implementação dessa funcionalidade demandou apenas estudar a sintaxe de estágios paralelos nativo do Jenkins e um código que separa as specs de acordo com a quantidade de PODs à ser executado. Jenkinsfile //imagem 1 Para utilizar a execução paralela do Jenkins é bem simples, quebramos as execuções dentro de contêineres diferentes e colocamos o comando para execução do Cypress dentro bloco de cada contêiner como na imagem acima. //imagem 2 Nessa parte do código devemos realizar a configuração do report Mocha Awesome onde toda a magia acontece, aqui você configura toda as variáveis e caminhos para que o report seja gerado corretamente e não seja perdido nenhum step. Colocamos abaixo algumas imagens para exemplificar a forma que o Jenkins exibe estes testes dentro de um Job. Pagina inicial do Job //imagem 3 Pagina de apresentação dos estágios pelo Blue Ocean //imagem 4 Visualização do console de execução no POD A //imagem 5 Visualização do console de execução no POD B //imagem 6 Como o report fica com a execução de forma paralela //imagem 7 Resultados da implementaçãoAbaixo está uma imagem onde apresentamos os resultados da nossa implementação de paralelização dentro do próprio Jenkins. Claramente percebemos que a execução de testes nesse modo demonstra um ganho de quase a metade do tempo nas execuções. //imagem 8 Caso queiram estudar a sintaxe de estágios em paralelo no Jenkins segue um exemplo interessante: Parallel stages Segue o link do projeto de exemplo de como essa funcionalidade foi implementada: Github Este artigo foi feito em conjunto com um amigo de equipe que ajudou a implementar essa funcionalidade. Obrigado por participar disso Danilo Juhas :) Valeu pessoal, até a próxima!","link":"/2020/06/paralelizacao-de-testes-com-Cypress/"}],"tags":[],"categories":[]}